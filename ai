<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AI Hunter</title>
  <style>
    body {
      margin: 0;
      background: #111;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      font-family: sans-serif;
    }
    canvas {
      border: 4px solid white;
    }
    .controls {
      display: grid;
      grid-template-columns: 80px 80px 80px;
      gap: 10px;
      margin-top: 20px;
    }
    .btn {
      background: white;
      color: black;
      font-size: 24px;
      border: none;
      border-radius: 8px;
      padding: 10px;
      touch-action: manipulation;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <div class="controls">
    <button class="btn" ontouchstart="press('ArrowUp')" ontouchend="release('ArrowUp')">⬆</button>
    <div></div>
    <button class="btn" ontouchstart="press('ArrowDown')" ontouchend="release('ArrowDown')">⬇</button>
    <button class="btn" ontouchstart="press('ArrowLeft')" ontouchend="release('ArrowLeft')">⬅</button>
    <div></div>
    <button class="btn" ontouchstart="press('ArrowRight')" ontouchend="release('ArrowRight')">➡</button>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const player = { x: 100, y: 100, size: 30 };
    const enemy = { x: 400, y: 300, size: 30 };
    const keys = {};

    const SPEED = 4;
    const ENEMY_SPEED = 2;

    const obstacles = [
      { x: 300, y: 200, w: 100, h: 20 },
      { x: 500, y: 400, w: 20, h: 100 },
    ];

    document.addEventListener('keydown', (e) => keys[e.key] = true);
    document.addEventListener('keyup', (e) => keys[e.key] = false);

    function press(key) {
      keys[key] = true;
    }
    function release(key) {
      keys[key] = false;
    }

    function isColliding(rect1, rect2) {
      return (
        rect1.x < rect2.x + rect2.w &&
        rect1.x + rect1.size > rect2.x &&
        rect1.y < rect2.y + rect2.h &&
        rect1.y + rect1.size > rect2.y
      );
    }

    function moveEnemyTowardPlayerWithAvoidance() {
      const directions = [
        { dx: 1, dy: 0 }, // right
        { dx: -1, dy: 0 }, // left
        { dx: 0, dy: 1 }, // down
        { dx: 0, dy: -1 }, // up
        { dx: 1, dy: 1 }, // diagonal
        { dx: -1, dy: -1 },
        { dx: 1, dy: -1 },
        { dx: -1, dy: 1 },
      ];

      let bestMove = null;
      let shortestDist = Infinity;

      for (let dir of directions) {
        const nextX = enemy.x + dir.dx * ENEMY_SPEED;
        const nextY = enemy.y + dir.dy * ENEMY_SPEED;
        const tempEnemy = { x: nextX, y: nextY, size: enemy.size };
        const collides = obstacles.some(obs => isColliding(tempEnemy, obs));
        if (!collides) {
          const dx = player.x - nextX;
          const dy = player.y - nextY;
          const dist = Math.hypot(dx, dy);
          if (dist < shortestDist) {
            shortestDist = dist;
            bestMove = dir;
          }
        }
      }

      if (bestMove) {
        enemy.x += bestMove.dx * ENEMY_SPEED;
        enemy.y += bestMove.dy * ENEMY_SPEED;
      }
    }

    function update() {
      if (keys['ArrowUp']) player.y -= SPEED;
      if (keys['ArrowDown']) player.y += SPEED;
      if (keys['ArrowLeft']) player.x -= SPEED;
      if (keys['ArrowRight']) player.x += SPEED;

      player.x = Math.max(0, Math.min(canvas.width - player.size, player.x));
      player.y = Math.max(0, Math.min(canvas.height - player.size, player.y));

      moveEnemyTowardPlayerWithAvoidance();

      if (Math.abs(player.x - enemy.x) < player.size && Math.abs(player.y - enemy.y) < player.size) {
        alert("Game Over!");
        player.x = 100;
        player.y = 100;
        enemy.x = 400;
        enemy.y = 300;
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = 'blue';
      ctx.fillRect(player.x, player.y, player.size, player.size);

      ctx.fillStyle = 'red';
      ctx.fillRect(enemy.x, enemy.y, enemy.size, enemy.size);

      ctx.fillStyle = 'gray';
      for (const obs of obstacles) {
        ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
      }
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    gameLoop();
  </script>
</body>
</html>
